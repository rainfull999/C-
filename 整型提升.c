/* 整型提升 & char 的原码和补码 */
// 如果是无符号数，高位直接补0；如果是有符号数，高位全补符号位；
// 初始化时，先写出赋值符号右边的补码，然后截断，赋值给左边的变量，再按规则整型提升，得到提升后的补码
// 最后按照不同的类型解读得到的补码。 
#include <stdio.h>
int main(void)
{
	char a = 255;
	// 255是 int，原码为 00000000 00000000 00000000 11111111；
	// a 是 char 类型，截断后原码为 11111111，最高一位 1 是符号位；
	// 整型提升后：
	// a 是有符号数，高位全补符号位，所以提升为：11111111 11111111 11111111 11111111； 
	// 当打印 %u = unsigned int 时，最高位 1 不是符号位，此时 a是正数，原码、反码、补码三码相等，所以 a = 4,294,967,295；
	// 当打印 %d = int 时，最高位 1 是符号位，此时 11111111 11111111 11111111 11111111 是补码，反码为 11111111 11111111 11111111 11111110，原码为 10000000 00000000 00000000 00000001，所以 a = -1；
	 
	unsigned char b = -1;
	// -1是 int，补码为 11111111 11111111 11111111 11111111；
	// b 是 unsigned char 类型，截断后补码为 11111111，最高一位 1 不是符号位；
	// 整型提升后：
	// b 是无符号数，高位全补0，所以提升为：00000000 00000000 00000000 11111111； 
	// 当打印 %u = unsigned int 时，最高位 0 不是符号位，此时 b 是正数，原码、反码、补码三码相等，所以 b = 255；
	// 当打印 %d = int 时，最高位 0 是符号位，此时 b 是正数，原码、反码、补码三码相等，所以 b = 255； 
	
	printf("a = %u\n", a); /* a = 4294967295 */
	printf("a = %d\n", a); /* a = -1 */
	
	printf("b = %u\n", b); /* b = 255 */
	printf("b = %d\n", b); /* b = 255 */
	
	printf("\n------------------------------------------------------------------------------------------------\n");
	
//	unsigned int i; /* i 是无符号数，恒大于等于 0 */
//	
//	for (i = 9; i >= 0; i--) /* 测试条件是 i >= 0，条件恒成立，会形成死循环 */ 
//		printf("%u\n", i); 

	printf("\n------------------------------------------------------------------------------------------------\n");
	
	char c[1000];
	int i = 0;
	
	for (i = 0; i < 1000; i++) /* char 的取值范围是 -128 ~ 127，共256个数 */
		c[i] = -1 - i; /* 数组元素的取值是从 -1， -2， ... ， -127， -128， 127， 126， ... , 2, 1, 0, -1, -2, ...这样逆时针循环的，共循环3圈多，不到4圈 */
		
	printf("%d\n", strlen(c)); /* 找到c数组中的 '\0'，即 0 ，所以循环进入第一圈末尾时 strlen 找到了 0 ，此时 strlen 返回 -1 到  1 之间的数字个数 255，255 就是字符串的长度 */
	
	return 0;
}

// char 的取值范围是 （-128 ~ -1）U（0 ~ 127），模为 2 ^ 8 = 256； 
// 原码：                 补码： 
// 0：0000 0000               0000 0000
// 1：0000 0001               0000 0001
// ...                        ... 
// 127：0111 1111             0111 1111    正数的原码和补码相等 

// -128：1000 0000            1000 0000    负数的反码 = 模的原码 - 负数的绝对值的原码 
// -127：1111 1111            1000 0001    e.g.: -1 的反码 =  256 的原码 - 1 的原码 = 1 0000 0000 - 0000 0001 = 1111 1111 = 127 的原码。 
// -126：1111 1110            1000 0010          -128的反码 = 256 的原码 - 128 的原码 = 1 0000 0000 - 1000 0000 = 1000 0000 = 128 的原码。 
// ...                        ... 
// -2：1000 0010              1111 1110
// -1：1000 0001              1111 1111
